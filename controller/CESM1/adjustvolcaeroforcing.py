#!/bin/env python3

########################## adjustvolcaeroforcing.py ###########################
# Script to convert the three-mode aerosol forcing file generated by the 
# feedback script to the single-mode volcanic aerosol forcing file used 
# in CESM1.0.4 during run time
#
# include in piControl:
# import adjustvolcaeroforcing as avf
# volcaerofile = "./CCSM4_volcanic_sai_2000-2100.nc"
# aerofile = strataero_path_namelist
# # after saving the new forcing file (strataero_ds.to_netcdf()):
# avf.main(aerofile, volcaerofile, timestamp)
# The above will automatically create a forcing file if not present.
# If the prototype file (./CCSM4_volcanic_1920-2100_prototype1_c200915.nc)
# is not found, you may update the relative path
#
# You may also create an empty forcing file on beforehand via the terminal:
# >> ipython # open interactive python session
# >> import adjustvolcaeroforcing as avf
# >> volcaerofile = ... # use value of strataero_path_namelist
# >> timestamp = 2000 # the -upcoming- year of simulation [1920-2100]
# >> avf.create_volcaerofile(volcaerofile, timestamp)
# >> quit()
#
# creation date: 18/12/23 (JdJ)
###############################################################################

import sys
import os
import numpy as np
import xarray as xr
from numba import guvectorize

# path to prototype file for creation volcanic aerosol file
prototypefile = "/projects/0/nwo2021025/cesm1_0_4/inputdata/atm/cam/volc/CCSM4_volcanic_1920-2100_prototype1_c200915.nc"


def create_volcaerofile(volcaerofile, year, prototypefile=prototypefile):
    """Create volcanic aerosol file given a prototype file
    
    volcaerofile : str
        name of the volcanic aerosol file to create
    year : int
        year of the new forcing data
        will create forcing file until 'year', plus one time step in the
        new 'year'.
    prototypefile : str, optional
        name of the file to use as a reference, must exist in directory
    """
    if os.path.exists(volcaerofile):
        print(f"{volcaerofile} already exists, remove file file first")
        return
    dsp = xr.open_dataset(prototypefile)
    dss = dsp.copy()
    if 'utime' in dss:
        dss = dss.drop('utime')
    encoding = {v:{
        'dtype':dss[v].encoding.get('dtype'),
        '_FillValue':dss[v].encoding.get('_FillValue')
    } for v in dss.variables}
    dss = dss.assign_coords(
        {'time2':('time',np.linspace(1920-1/12,2101,2174),)}
    ).swap_dims({'time':'time2'}).drop('time').rename({'time2':'time'})
    tf = list(dss.time >= year).index(True) 
    dss = dss.isel(time=slice(0,tf+1))
    assert int(dss.time[-1]) == int(dss.time[-2])+1, ("The last time stamp of "
        + "{volcaerofile} should be in a new year for interpolation purposes.")
    dss.attrs = {
        'title': 'Volcanic Aerosol Mass Mixing Ratio for CESM1.0.4',
        'origin': ('derived from GLENS monthly aerosol data'
            + '(b.e15.B5505C5WCCML45BGCR.f09_g16.feedback.EM1-20)'),
        'aerosol_distribution':('Single aerosol distribution: sulfuric'
            + 'acid with reff 0.4264, med 0.375, sigma 1.25'),
    }
    print(f"creating {volcaerofile} from prototype {prototypefile}")
    dss.to_netcdf(volcaerofile, encoding=encoding, unlimited_dims='time')
    dsp.close()
    dss.close()


@guvectorize(
    "(float64[:], float64[:], float64[:], float32[:])",
    " (n), (n), (m) -> (m)",
    nopython=True,
)
def interp1d_gu(f, x, xi, out):
    """Interpolate field f(x) to xi in ln(x) coordinates."""
    i, imax, x0, f0 = 0, len(xi), x[0], f[0]
    while xi[i] < x0 and i < imax:
        out[i] = np.nan      
        i = i + 1
    for x1,f1 in zip(x[1:], f[1:]):
        while xi[i] <= x1 and i < imax:
            out[i] = (f1-f0)/np.log(x1/x0)*np.log(xi[i]/x0)+f0
            i = i + 1
        x0, f0 = x1, f1
    while i < imax:
        out[i] = np.nan
        i = i + 1

        
def xr_interp(ds, pi):
    """interpolate dataset ds to pressure levels pi"""
    dsi = xr.apply_ufunc(
        interp1d_gu, ds, ds.P, pi,
        input_core_dims=[['lev'],['lev'],['lev']],
        output_core_dims=[['lev']],
        exclude_dims={'lev'},
        keep_attrs=True,
    ).drop('P')
    dsi['lev'] = pi
    return dsi


def yearfrac(time):
    """Convert cftime to years (float)"""
    if isinstance(time, xr.DataArray):
        frac = list(map(yearfrac, time.data))
        return xr.DataArray(data=frac, coords=time.coords, dims=time.dims)
    yearstart = time.__class__(time.year,1,1)
    yearend = time.__class__(time.year+1,1,1)
    return (time-yearstart)/(yearend-yearstart)+time.year


def main(aerofile:str, volcaerofile:str, year:int):
    """Convert 3-mode aerosol forcing file to single-mode volcanic aerosol
    forcing file as needed by CESM1.0.4. Results are appended to an existing
    forcing file if present.
    
    args:
    -----
    aerofile : str
        path to 3-mode aerosol forcing file produced by feedback controller
    volcaerofile : str
        path to volcanic aerosol file
        is created from prototype if it does not exists
    year : int
        year to convert (upcoming year in CESM simulation)
    """
    assert os.path.exists(aerofile), "could not find "+aerofile
    assert os.path.exists(prototypefile), "could not find "+prototypefile
    if not os.path.exists(volcaerofile):
        create_volcaerofile(volcaerofile, year)

    # open 3-mode aerosol file
    # need to select only relevant time steps (upcoming year + 1 step)
    dsa = xr.open_dataset(aerofile)
    t0 = list(dsa.time.dt.year).index(year)
    t1 = list(dsa.time.dt.year).index(year+1)
    dsa = dsa.isel(time=slice(t0,t1+1))

    # open volcanic aerosol forcing file
    dsv = xr.open_dataset(volcaerofile)
    dsv = dsv.isel(time=slice(0,-1)) # remove last point

    # calculate 3d pressure and volcanic aerosol mixing ratio
    dsa['P'] = (dsa.hyam * dsa.P0 + dsa.hybm * dsa.PS)/100
    dsa['MMRVOLC'] = dsa.so4_a1 + dsa.so4_a2 + dsa.so4_a3
    dsa.MMRVOLC.attrs = dsv.MMRVOLC.attrs

    # interpolate pressure and latitude
    dsi = xr_interp(dsa[['P','MMRVOLC']], dsv.lev)
    dsi = dsi.transpose(*dsv.dims, missing_dims='ignore')
    dsi = dsi.interp(lat=dsv.lat)

    # integrate MMRVOLC to get colmass
    dlev = [dsi.lev.data[0],*dsi.lev.diff('lev').data]
    dlev = xr.DataArray(dlev, coords={'lev':dsi.lev},dims='lev')
    dm = 100*dlev/9.68077
    colmass = (dsi.MMRVOLC*dm).sum('lev',keep_attrs=True)
    colmass.attrs = {'units':'kg m-2', 
                     'long_name':'volcanic aerosol column mass'}
    dsi['colmass'] = colmass.astype(dsv.colmass.dtype)

    # set date and time
    ctime = dsa.time_bnds.mean('nbnd') # time at mid interval
    dt = ctime[-2].item() - ctime[-3].item()
    ctime[-1] = ctime[-2] + dt # replace last value manually
    time = yearfrac(ctime)
    dsi['time'] = time.astype(dsv.time.dtype)
    dsi['date'] = (
        'time', 
        ctime.dt.strftime("%Y%m%d").astype(dsv.date.dtype).data,
        dsv.date.attrs
    )
    dsi['datesec'] = (
        'time', 
        ctime.dt.second.astype(dsv.datesec.dtype).data,
        dsv.datesec.attrs
    )
    dsi['datesec'] = dsi.datesec.astype(dsv.datesec.dtype)

    # set global attributes
    dsi.attrs = {
        'title': f'Volcanic Aerosol Mass Mixing Ratio for CESM1.0.4',
        'origin': ('derived from GLENS monthly aerosol data'
            + '(b.e15.B5505C5WCCML45BGCR.f09_g16.feedback.EM1-20)'),
        'aerosol_distribution':('Single aerosol distribution: sulfuric'
            + 'acid with reff 0.4264, med 0.375, sigma 1.25'),
    }

    # save file
    # xarray does not allow appending to data, hence
    encoding = {v:{'_FillValue':dsv[v].encoding.get('_FillValue'),
                  'dtype':dsv[v].encoding.get('dtype')} 
                for v in dsi.variables}
    dsf = xr.concat((dsv,dsi),dim='time',join='right')
    print(f"appending forcing data to {volcaerofile}")
    dsf.to_netcdf(volcaerofile+'temp', encoding=encoding, 
                  unlimited_dims='time')
    os.replace(volcaerofile+'temp',volcaerofile)
    yearvolcaerofile = volcaerofile.replace('.nc',f'-{year}.nc')
    print(f"saving year {year} forcing to {yearvolcaerofile}")
    dsi.to_netcdf(yearvolcaerofile, encoding=encoding, 
                  unlimited_dims='time')

    # close datasets
    dsa.close()
    dsv.close()
    dsi.close()
    dsf.close()
    
    
if '__name__' == '__main__':
    main(sys.argv[1:])
